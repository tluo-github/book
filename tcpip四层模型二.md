# TCP\/IP 网络互连层IP 协议

> 上TCP\/IP四层模型中我们大致了解了下是哪四层及每层大致作用，做为web程序员除了最底层不用太了解从网络互连层\(TP协议\)-&gt;传输层\(TCP,UDP\)-&gt;应用层 都应了解越详细越好，这篇就主要记录我理解的网络互连层 IP 协议

### 1、 网络互连层 IP 协议 定义

**网际协议**（英语：Internet Protocol，缩写为 **IP**），或称**互联网协议**，是用于**报文交换**网络的一种面向数据的协议。

1. IP是TCP\/IP协议族中最为核心的协议。所有的TCP，UDP，ICMP，IGMP数据都是以IP数据报格式传输。IP协议就是定义数据如何从源地址传送到目的地址，同时也定义在传输过程中的数据分片和重新组装

2. IP协议是被它的上层协议（TCP，UDP）调用，同时它也调用它的下层协议（以太网协议，IEEE802），把IP数据报传到下一个网关（gateway）或目的地址

3. IP协议主要实现两个基本功能：寻址和数据分片


#### 1.1 寻址

> 寻址就是如何将IP地址分配给各个终端节点，以及如何划分和组合子网。

![](http://image.beekka.com/blog/201205/bg2012052908.png)

习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。

互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。

但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。

那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数"子网掩码"（subnet mask）。

所谓"子网掩码"，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。

知道"子网掩码"，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。

比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。

### 1.2 IP数据包

![](http://s1.sinaimg.cn/orignal/4b503921475bd7925f320&690)
![](http://images.cnitblog.com/blog/322405/201301/30232516-5ef120a7fcc14f0fabb87c96b966dbce.jpg)
* **version（版本）：**长度4比特，指采用的IP协议的版本号。目前一般值为0100\(IPv4\)以后会是0110\(IPv6\)
* **internet header length（首部长度）:**长度4比特，指IP包头长度。以4字节(32比特)为单位。从图中看出每一行32比特。1字节=8比特，固定部分有5行就是32*5=160比特。也就是160/8=20字节。所以最小值为20字节。由于IHL占4比特，4比特可表示的最大十进制值是15.因此当IHL的值为1111时(即十进制的15)，首部长度就达到15*32bit/8=60字节。
* **Type of service(服务类型)：** 前三个比特指优先权字段（已被忽略）。中间四个比特表示：最小时延，最大吞吐量，最高可靠性，最小费用。0表时一般，1表示最优。四个中只能一个置1。最后一比特预留，总置为0
* **Total length(IP数据总长度)** ： IP数据报内容的长度，包括IP头部部分，以字节为单位。因为占16比特，所以最长为65535（2^16-1）。尽管IP数据报最长可以达65535字节，但是我们知道有些链路层有最大传输单元的限制（MTU），如以太网就是1500，这时候IP数据报就要分片（Fragmentation）传输。
* **Identification(唯一标识)：** 每一个IP数据报都要有唯一的标识字段，这样在分片和重组时不至于混淆两个完全不同的分片数据。这在后面分组，重组中会讲到
* **Flages(标志)：** 这个字段也是为IP数据报的分片和重组作用的。用于标识收到的分片后续是否还有分片待接收。
* **Fragment offset(分片偏移)：**指当前分片数据在整体IP数据报中所处的偏移量，以8字节（64比特）为单位。由此可见,「identification」，「Flages」,「Fragment offset」这三个字段是为IP数据报分片和重组功能作用的字段
* **Time to live(生存时间) ：** 设置IP数据报可以经过的最多路由器数目。每次经过一次处理它的路由器，它的值就减1，值到为0时，该数据报丢弃，并发送ICMP报文到源主机。
* **Protocol(协议) ：** 指定它的上层协议，如TCP。
* **Header checksum(头检验和) **： 为了验证IP头数据的完整性，进行一系列计算求出的检验和值，当接收方收到后也要进行同样的计算并把求出的检验和与收到的相比较，以判断IP数据在传输的过程中是无误传输的。
关于计算检验和的算法，在RFC1071里定义。我没有详细看这份rfc，但是这篇文章介绍得挺详细的。
* **source address** 和 **destination address** 分别指源IP地址和目的IP地址。
* **Options（可选项）**：这是一个可变长的字段。该字段属于可选项，主要用于测试
* **Padding（填充）**：因为IP包头长度（Header Length）部分的单位为32bit，所以IP包头的长度必须为32bit的整数倍。因此，在可选项后面，IP协议会填充若干个0，以达到32bit的整数倍。 





### 1.3 ARP协议

因为IP数据包是放在以太网数据包发送，所以我们必须同时知道2个地址，一个对方的MAC地址，一个对方的IP地址。通常情况下，对方的IP地址是已知的，但是不知道它的MAC地址。所以我们需要一种机制，能够从IP地址获得MAC地址

这里有两种情况：

一 如果两台主机不再同一个局域网，那么事实上没有办法获得对方MAC地址。只能发数据发送到2个网络之间的路由转发。

二 如果在同一个网络中，那么可以使用ARP协议，得到对方的MAC地址。每天电脑或路由器都有一个ARP缓冲表，表里的IP地址与MAC地址是一一对应的。

| 主机名称 | IP地址 | MAC地址 |
| --- | --- | --- |
| A | 192.168.38.10 | 00-AA-00-62-D2-02 |
| B | 192.168.38.11 | 00-BB-00-62-D2-02 |
| C | 192.168.38.102 | 00-CC-00-62-D2-02 |
| ... | ... | ... |

以主机A（192.168.38.10）向主机B（192.168.38.11）发送数据为例。

当发送数据时，主机A会在自己的ARP缓存表中寻找是否有目标IP地址。如果找到就知道目标MAC地址为（00-BB-00-62-C2-02），直接把目标MAC地址写入帧里面发送就可。

如果在ARP缓存表中没有找到相对应的IP地址，主机A就会在网络上发送一个广播（ARP request），目标MAC地址是“FF.FF.FF.FF.FF.FF”，这表示向同一网段内的所有主机发出这样的询问：“192.168.38.11的MAC地址是什么？”网络上其他主机并不响应ARP询问，只有主机B接收到这个帧时，才向主机A做出这样的回应（ARP response）：“192.168.38.11的MAC地址是00-BB-00-62-C2-02”。这样，主机A就知道主机B的MAC地址，它就可以向主机B发送信息。同时它还更新自己的ARP缓存表，下次再向主机B发送信息时，直接从ARP缓存表里查找就可。

所以，ARP协议\( **地址解析协议**（**A**ddress **R**esolution **P**rotocol \) 其基本功能为透过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。

